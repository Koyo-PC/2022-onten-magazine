---
title: ガチ初心者のためのプログラミング入門
author: ZOI
---

## 自己紹介など

こんにちは。ZOIといいます。パソコン同好会でいろいろつくって遊んでる人です。
突然ですが、「プログラミングやってみたいけど難しそう」と思ったことはありませんか?
「数学や英語の能力がいる」とか、「めっちゃタイピング早くないといけない」とか言われているプログラミングですが、
実際にやってみると、(めっちゃ高度なことをしない限り)そんなに難しいものではないんです!
まずは、騙されたと思ってこの記事を読んでみてください。

## お絵描きアプリを作ってみる

### 関数と変数

さっそくプログラミングをしていきます。
特別に必要なものはほとんど無いです。
ひとまずパソコンとインターネット回線、そしてYouTubeで動画を捜せる程度のタイピング能力さえあればどうにかなります。

ネットで「プログラミング 始めかた」とかで検索すると、黒い画面に「Hello World」とか表示させるようなページがいっぱいでてくると思います。
それはそれで後で役に立つのですが、驚くほど楽しくないです。
ので、そんな地味なことはせず、絵を描くアプリを作ってみましょう。

まずは、Googleとかで「Open Processing」と検索して、上のほうにでてきたページを開いてください。
うわーいきなり英語かーと思うかもしれませんが、そんなことは気にせず右上の「Create a Sketch」というボタンを押してみましょう。
はい。
さっきのデザイナーみたいなページとは一転、いきなりプログラミング感あふれるページになりましたね。
なにやら最初からコードが書いてあります。
これを実行してみましょう。
上部中央の三角ボタンを押すと実行されます。

画面が灰色になるだけではなく、マウスを振ると丸がいっぱい描画されます。
なんでしょうこれ。
ではコードを見てみましょう。
上部中央の`</>`というボタンでコードの画面に戻れます。
こんなコードがかいてあるはずです。

```javascript
function setup() {
	createCanvas(windowWidth, windowHeight);
	background(100);
}

function draw() {
	circle(mouseX, mouseY, 20);
}
```

なんかすごいプログラミングってかんじの見た目ですが、落ち着いて見てみるとそこまで読めないものではないんじゃないでしょうか。
まず、`{}`で大きく2つのブロックに分かれていますね。
`function`は**関数**という意味です。
プログラミングでは、とりあえず現時点では「関数」=「コードをまとめたカタマリ」と思ってもらって大丈夫です。
関数は、呼び出されたとき、その内容を上から順番に実行してくれます。

この2つの関数は、それぞれ`setup()`、`draw()`と名前がついています。
このコードが実行される順番ですが、OpenProcessingが勝手にsetup()→draw()→draw()→draw()→draw()...というふうに呼び出してくれます。
(なので、このdrawを勝手に他の名前にすると動きません。)

まず、1行しかないdraw()の中を見てみましょう。
さっきマウスの場所に丸が描かれていましたが、`draw()`という名前から想像できるように、この関数の中で描かれています。
`circle(~, ~, ~)`というのがありますが、この`circle()`ってのも関数です。
そんな関数どこにも定義されてないぞ?って思うかもしれませんが、この関数はOpenProcessingが勝手に定義しているものです。
`circle(x, y, r)`と実行しれば、中心(x, y)、半径rの円が描かれることになっています。
今回、xやyには`mouseX`、`mouseY`という謎の文字が書いてますね。
この場所には数字が入るはずなのですが。
このような、数を表している文字を「**変数**」といいます。(厳密には違いますが...)
これらの変数は、名前から分かる通り、マウスのXY座標を表しています。
(「関数」「変数」と立て続けに出てきましたが、関数は**処理をする**のに対して、変数は数値など**ある値を表します**。
`mouseX()`のようにカッコをつけないように気をつけましょう。)
これによって、「マウス位置に丸を描く」という処理ができるのです。
ちなみに、circleを2つ、こんな感じで書いてみると...

```javascript
// setup() は省略

function draw() {
	circle(mouseX, mouseY, 20);
	circle(mouseX + 100, mouseY, 20);
}
```

同時に2つの円が描かれるコードができました。

ちなみに、僕がコードに書いた`//`ですが、これは「この行のここから先は無視してね」という記号です。
こういう無視される部分は**コメント**と呼ばれ、今回のようにちょっとした注釈を書いたり、その行を一時的に無効にするという使い方もできます。
この行は消しても普通に動作します。

次にsetup()を見てみましょう。
これは最初に1回だけ実行されるコードなので、描く前の初期設定などが書かれています。

```javascript
function setup() {
  // キャンバス(描く部分)を作成
  // 高さは画面の高さ、幅は画面の幅
	createCanvas(windowWidth, windowHeight);

  // 背景色を「100」に設定
  // 0で真っ黒、255で真っ白
	background(100);
}

// draw() は省略
```

まあここについてはあんまり考えなくていいです。

### 公式ドキュメント

最初から書かれていたコードは大体読めたと思いますが、自分で書くとなればまだ問題があるはずです。
さっき、`circle()`や`createCanvas`などはOpenProcessingが定義している関数であると言いましたが、もちろん他にもいろいろあります。
一体どんな関数や変数を定義しているのでしょう?
もちろん勘で見つけるものではなく、公式がまとめてくれています。

コードを書く画面の右上に赤い「Save」というボタンがありますが、そのちょうど下にある本のマークを押してみましょう。
ここに表示されている関数・変数はすでに定義されているので使えます。
(<https://p5js.org/reference>にも同じ内容が書かれています。)

なにか一つ使ってみましょう。
たとえば線をひいてみましょう。
検索に「line」と打ち込んでみると、Shapeというカテゴリにlineというのがありますね。
この状態では使いかたが全くわからないので、リンクをクリックして詳しい情報を見てみましょう。
英語のページですが、最悪Exampleさえ見ておけばなんとかなります。
どうやら`(x1, y1)`から`(x2, y2)`まで線を引いてくれるようです。
つまり、

```javascript
// setup() は省略

function draw() {
  // circleは一旦動かないようにしておく
	// circle(mouseX, mouseY, 20);
	line(0, 0, mouseX, mouseY);
}
```

として実行してみれば、原点(左上)からマウス位置まで線が引かれます。
公式ドキュメントが読めるようになれば、できることが大きく広がります。

### 変数の利用

さて、ここでの目的は絵を描くことでした。
そのためには、「一瞬前のマウスの位置」から「今のマウスの位置」に線を引きたいですよね。
さて、「一瞬前のマウスの位置」ってどう取得するんでしょう。
さっき、`draw()`は繰り返し呼ばれるといいました。
一回前に`draw()`が呼ばれたときのmouseX, mouseYが使えたらいいのですが。
なので、次のときに使うために、毎回mouseX, mouseYを「メモ」しておくことにしましょう。

こんなときに役にたつのが、さっきも紹介した「変数」です。
いま使っている変数「mouseX」はOpenProcessingが定義してくれたものですが、自分で勝手に定義することもできます。
やってみましょう。

```javascript
let x = 20;
let y = 30;

// setup() 省略

function draw() {
	circle(x, y, 20);
}
```

これを実行してみると、(20, 30)に円が描かれます。
`let`という行が増えていますね。
letというのは変数を定義するやつです。
変数はなにか値を表すのですが、1行目では`x`という名前の変数をつくり、20を表すように設定しています。

また、変数は`=`を使うことでその値を書き変えることができます。
なので、こんなふうに書き変えてみると、xやyが1ずつ増えていき、円が少しずつずれて描かれるはずです。

```javascript
// let 省略
// setup() 省略

function draw() {
	circle(x, y, 20);
  x = x + 1;
  y = y + 1;
}
```

ここまでできたら後は簡単です。

さっきのコードを少し変えてみます。

```javascript
let x = 0;
let y = 0;

// setup() 省略

function draw() {
	// circle(x, y, 20);
  line(x, y, mouseX, mouseY);
  x = mouseX;
  y = mouseY;
}
```

マウスの動きに沿って線を描くことができました。
(いまさらですが、「一瞬前のマウス位置」は pmouseX, pmouseY で取得できるらしいです。
まあ勉強ということで。)

### if分岐とフラグ

ただ、線が左上から始まってしまうのは嫌ですね。
最初の1回は線を描かないようにしましょう。
初めの1回かどうかをメモっておく、ということで、変数が使えそうです。
とりあえず、今何回目かを表す変数「count」を作りましょう。

```javascript
// let x, y 省略
let count = 0;

// setup() 省略

function draw() {
  // 省略
  count = count + 1;
}
```

ここで、「countが0のときは線を描かない」という処理がしたいですよね。
こんなときには`if`が使えます。
if(条件){処理}という形でつかいます。
実際にやってみたほうが早いです。

```javascript
// let 省略

// setup() 省略

function draw() {

  // A != B で「AとBが等しくない」という意味です

  if(count != 0) {
    line(x, y, mouseX, mouseY);
  }
  x = mouseX;
  y = mouseY;
  count = count + 1;
}
```

ただ、これではうまくいきません。
マウスが枠のなかに無いのにdraw()が呼びだされることがあるのです。
なので、「今までに一度でもマウス位置が更新されたか」を取得したいですね。
(直前のマウスの位置が0,0でない、というのでも動くのですが、マウスがたまたま0,0にいったとき動かないので...)
もし一度でもマウスに反応したら「x != 0」もしくは「y != 0」となるので、これを使いましょう。
2つの条件A、BをORでつなぎたい場合、「A || B」と表せます。
ちなみにANDのときは「A && B」です。

あともう一つ。
今回、「すでに動いたか」を表す変数として「isMoved」を作るのですが、これには数字ではなく「はい」または「いいえ」という値を入れたいです。
こんなときは、変数に数字ではなく「true」(はい)、「false」(いいえ)を入れることができます。
もちろん四則演算はできなくなりますが、ifの括弧の中に直接入れることができます。

```javascript
// let x, y 省略
let isMoved = false;

// setup() 省略

function draw() {
  // このifはなくても動くのですが、既にisMovedなら判定する必要がないので、一応書いています。
	if(!isMoved){
	  if(x != 0 || y != 0){
	    isMoved = true;
	  }
	}
  if(isMoved) {
    line(x, y, mouseX, mouseY);
  }
  x = mouseX;
  y = mouseY;
}
```

さて、これでマウスの動きに合わせて線を引くコードが書けました。
ですが、これでは一筆書きしか描けないので不便です。
マウスが押されている間だけ描くことにしましょう。
マウスが押されている間は`mouseIsPressed`がtrueになるので、これを使いましょう。

```javascript
// let x, y 省略
let isMoved = false;

// setup() 省略

function draw() {
  // このifはなくても動くのですが、既にisMovedなら判定する必要がないので、一応書いています。
	// if(!isMoved) 省略
  if(isMoved) {
    if(mouseIsPressed){
      line(x, y, mouseX, mouseY);
    }
  }
  x = mouseX;
  y = mouseY;
}
```

もちろん、if()が深くならないように、2行のifを`if(isMoved && mouseIsPressed)`とまとめることもできます。

### イベントの利用

描いた画像を保存できるようにしましょう。

画像の保存自体は`saveCanvas()`という関数が用意されているのでできるのですが、ユーザーの操作に応じて保存しなければいけません。
このような時に使えるのが、イベントという考え方です。
今回はキーボードのSキーを押したときに保存するようにします。

まず、setup()やdraw()と同様にkeyPressed()をつくりましょう。
setupは開始時に、drawは一定間隔で呼び出されましたが、keypressedは何らかのキーが押されたときに呼び出されます。

keyPressed()の中では、特別な変数「key」が使えます。
keyには押されたキーが入っているので、これを使えば目的のキーが押されたのか判別することができます。

これまでに説明したことを使えば、こんなコードが書けるのではないでしょうか。

```javascript
// let 省略
// setup(), draw() 省略

function keyPressed() {
	if(key == "s") {
		saveCanvas('test', 'png');
	}
}
```

### 完成

さて、なんとなく絵が描けるプログラムができました。
全体のコードはこんなかんじです。

```javascript
let x = 0;
let y = 0;
let isMoved = false;

function setup() {
  createCanvas(windowWidth, windowHeight);
  background(255);
}

function draw() {
  if(!isMoved){
    if(x != 0 || y != 0){
      isMoved = true;
    }
  }
  if(isMoved && mouseIsPressed) {
    line(x, y, mouseX, mouseY);
  }
  x = mouseX;
  y = mouseY;
}

function keyPressed() {
  if(key == "s") {
    saveCanvas();
  }
}
```

## ゲーム開発

お絵描きアプリを作ることができたわけですが、はっきり言ってこんなアプリ使いませんよね。
ここからは、実際にゲームを作って遊んでみましょう。

何を作ってもいいんですが、比較的簡単なのでマリオみたいなものを作ります。

### Unityのインストール

ところでいきなりですが、マリオって「落ちる」という動作をしますよね。
何を言っているんだと思われるかもしれませんが、これがけっこう大変なんです。
よく考えてみてください。
ジャンプして落ちてくるときの位置って放物線、つまり二次関数です。
もうあんまりやりたくないですが、この上どこで止まるかも知らないといけません。
人の形は長方形に近似することが多いのですが、この長方形をさっきの二次曲線にそって動かし、通過領域を計算して、他のオブジェクトとの交点を調べることになります。
嫌ですね。

こんなときは、他の人が作ったツールを借りてきましょう。
自分でバグだらけのコードを書いて時間を使うより、多くの人が使っているコードを使うほうがずっといいです。

こういう物理演算、というよりゲーム全般を作るのによく使われているのが「Unity」です。
有名なところでは、「Pokémon GO」、「原神」、「ウマ娘」、「DEEMO」などに使われています。
すごい。

なにはともあれインストールです。
Unityは、まずUnity Hubを入れてそこからUnityを入れるというちょっと特殊な構造をしているのですが、まあ画面の指示に従えばできると思います。
こちらから「Unity Hubをダウンロード」です→<https://unity3d.com/jp/get-unity/download>

Unity Hubの「インストール」から好きなバージョンをインストールしましょう。
途中でモジュールをインストールするか聞かれると思いますが、特にこだわりがなければ「Visual Studio」、「Windows Build Support」「Documentation」、「日本語」あたり入れておけば良いです。10GB以上使うので注意してください。

// Unity IDの登録、Licenseの設定やってなくね

### Unityの使い方

とうとうUnityの起動です。
Unity Hubを開くと、「新しいプロジェクト」というボタンがあると思います。
そこから「2D」を選び、プロジェクト名は「ActionTest」、保存先は「C:\Develop\Unity\」みたいな感じで設定して作成しましょう。
少し経った後に新しいウィンドウが立ち上がったと思います。
これがUnityの本体です。

ゲームを作り始める前に、使いそうな素材を準備しておきましょう。
とりあえず、プレイヤーと地面ブロックを作っておきます。
画像作成アプリはGimpかFireAlphacaあたりがおすすめですが、何でもいいです。
16x16くらいの画像で、いい感じに描いてみましょう。
($2^n$四方の画像を使うことが多いです。)
さっき作ったフォルダのAssetsの中に入れておいてください。
次に、Unityで今作った素材を選んでください。
右側のメニューに「Pixels Per Unit」というものがあると思います。
いまのままでは、この地面ブロックはパソコンでの16px、つまり文字ひとつ分くらいの大きさで表示されてしまいます。
ここの値を100くらいにして大きく表示されるようにしておきましょう。

マップの作成には、Unityの「タイルマップ」という機能を使います。
画面上部の「Window」メニューの中に「2D」がありますが、さらにその中の「Tile Palette」をクリックしてください。
このウィンドウはタイルパレットと呼ばれ、絵を描く時のパレットのように、使える素材を一覧表示できます。
地面のタイルを登録しておきましょう。
「Create New Palette」を押し、Nameに好きな名前を入れてCreateを押します。
Drag File...とか書いてあるところに、さっき作った地面の画像をドラッグしてきます。
これでタイルパレットは完成です。

次に、今作ったタイルを使って地面を作ります。

// タイルの設置

// プレイヤーの移動

次に、プレイヤーを移動させます。
ただ、今までと同じようにタイルマップを使った方法だと、マス目ごとにしか動くことができません。
初代ドラゴンクエスト以下です。
これを防ぐために、プレイヤーを別のゲームオブジェクトとして作ります。

// 新規GameObjectを作成
// Rigidbody?
// 再生
// 地面の当たり判定
// スクリプト
// 敵の作成

## オブジェクト指向

UnityではC#が使われるのですが、C#やC++、Javaなどでコードを書く際は「オブジェクト指向」という考え方をすることが多くあります。
オブジェクト指向では、データ構造と手続き、平たく言えば変数と関数を一つのオブジェクトとしてまとめます。

// 単一責任の原則

## おまけ: Git

<!-- ## ゲーム開発 (Unity) -->

---

## MinecraftのPlugin開発

## MinecraftのMod開発

---

## CLI

### パッケージマネージャー

## Linux

### OSとは?

### Vim

### Docker

### 仮想環境

## サーバー管理

### ネットワークの基礎知識

---

## セキュリティ

### ウイルスの感染経路

### ハッキング

---

## Web開発

### Chrome

### HTML

### CSS

### JS

### JSフレームワーク

---

## TeX

---

## スマホアプリ開発 (Flutter)

---

## プログラミングを根本から理解する

### 処理とは

#### CPU

#### メモリ

### 機械語

### アセンブリ

### C

### 自作言語

## 自作OS

// とりあえず仮想環境まわりのこともここに書いとく

OSを自作すると聞いて、「OSって何?」と感じる人も少なくないと思うので、説明します。
OSとはオペレーティングシステム(Operating System)の略なのですが、これを聞いてもよく分からないと思います。
CPUやメモリなどのハードウェアはコンピュータによって少しずつ違うのですが、これらの差を埋めてまるで同じように扱えるようにするものだと思ってください。
IntelのCPUでも、AMDのCPUでも、Windowsはまったく同じように動きますよね。
あれがOSの意義なのです。
身近なものでは、Windows、MacOS、Android、iOSなどがあります。

さてOSとは何かも分かったので早速作っていこう、と行きたいですが、まずは環境構築です。
これを読んでいる方はWindowsかMacを使っているのではないかと思いますが、今回はLinuxで開発します。
こういう低レイヤというか、コンピュータの奥底を触るときにはLinuxのほうが使いやすいのですが、今入っているWindowsを消してLinuxを入れるわけにもいきません。
そこで、「仮想OS」というものを使います。
これは、本来`CPU -> OS -> アプリ`となっているところを`CPU -> OS -> アプリ -> OS -> アプリ`とすることです。
アプリがCPUのふりをしている感じです。
もとのOSを停止しなくてももう一つのOSを立ち上げられるので便利ですが、もちろん合計で2倍すこしの性能を使います。

<!--
使うアプリは大抵の場合「VirtualBox」というものでいいです。
(もしAppleのMシリーズのCPUを使っているならこれは使えません。
Mシリーズはarmという設計のCPUなのですが、今から動かそうとしているLinuxはx86という設計のCPUで動かすために作られています。
ので、OSだけでなくCPUの設計までごまかせる「UTM」というアプリを使いましょう。)

使うOSはUbuntu Server 22.04です。
<https://jp.ubuntu.com/download>からisoファイルをダウンロードして、好きな場所に保存しておきます。
次にVirtualBoxなどを開き、仮想PCを作ります。
-->

- Windowsを使っている人
Windowsでは、WSLという機能が使えます。

- Macを使っている人
limaというアプリを使いましょう。
`$ brew install lima`で入れることができます。
完了したら、`~/.lima/ubuntu_osdev.yaml`など好きな場所にyamlファイルを作ってください。
そこに以下の内容を書き込みます。
<https://github.com/lima-vm/lima/raw/master/examples/ubuntu.yaml>を参考に、M1 Macでもx86_64で起動するように設定を少し変更しています。
```
arch: "x86_64"
images:
- location: "https://cloud-images.ubuntu.com/releases/22.04/release-20220420/ubuntu-22.04-server-cloudimg-amd64.img"
  arch: "x86_64"
  digest: "sha256:de5e632e17b8965f2baf4ea6d2b824788e154d9a65df4fd419ec4019898e15cd"
- location: "https://cloud-images.ubuntu.com/releases/22.04/release/ubuntu-22.04-server-cloudimg-amd64.img"
  arch: "x86_64"
mounts:
- location: "~"
  writable: true
cpus: 2
memory: "8GiB"
disk: "50GiB"
ssh:
  loadDotSSHPubKeys: false
```
できたら、`$ limactl start ~/.lima/ubuntu_osdev.yaml`で起動します。
何か質問されるかもしれませんが、`Proceed ~`ってやつでいいと思います。
OSのダウンロードが始まります。

// 中略

とりあえず起動してセットアップします。
まず仮想OS上で`$ sudo apt update`、`$ sudo apt upgrade`と実行します。
これで今入っているアプリをアップデートできます。

<!--
次にエディタを用意します。
今使っているのはLinux、それもデスクトップのないServer版なので、いつも使っているVSCodeなどのエディタは使えません。
sshfsやscpなどを使えばできますが、ここでは特に解説しません。
最初から入っているVimというエディタを使います。
異常に操作が特殊なエディタなのですが、

- 上下左右への移動はそれぞれK、J、H、L
- ファイルの保存は`:w`、Vimの終了は`:q`

であることを覚えておけば、頑張れば編集できるはずです。
-->

開発を始める前に、まずは必要なアプリを入れます。
`$ sudo apt install libc6-dev-i386`でi386用のコンパイラ(プログラミング用のツール)を入れます。
234MBくらい使うらしいです。

<!--
そのまえに、コンピュータがどうやって計算をしているか考えてみましょう。
コンピュータは基本的に「CPU」という部品を使って計算をしています。
CPUは集積回路の一つで、半導体でスイッチみたいに働いてくれるトランジスタがいっぱい集まった構造をしています。
では、トランジスタ、つまりはスイッチを組み合わせるだけで、なぜ計算ができるのでしょう?
たとえば、入力A、Bに対して、次の表のような出力を出す回路を考えてみます。
(ここではA、Bはデジタル、すなわち0か1であるとします。)

| A | B | 出力 |
| - | - | ---- |
| 0 | 0 | 0    |
| 0 | 1 | 0    |
| 1 | 0 | 0    |
| 1 | 1 | 1    |

いわゆる「AND回路」です。
電気の話になってしまうのでここでは省略しますが、トランジスタをうまく繋げると、この対応を作ることができるわけです。
同じようにしてNOTやOR、XORなどと呼ばれる回路も作ることができます。
たとえば足し算の場合、XORで計算を、ANDで繰り上がりを作れば、2進数の足し算を作ることができます。
これがCPUの正体です。
ただ、CPUで動くプログラムを作ろうとしたときに、「○番ピンに電気を送って、△クロック後に□番ピンに...」なんて考えていれば人生が終わってしまいます。
そこはCPUを作っている専門家がどうにかしてくれるのですが、これより簡単とはいえ、「メモリの○番地に△を書き込み...」くらいのことは考えないといけません。
しかも、CPUには英語なんて分からないので、プログラムは0と1で書くことになります。
これが機械語です。
-->
